#include "Engine.h"

namespace Atlas {

	Window *Engine::Init(std::string assetDirectory, std::string shaderDirectory, std::string title,
						 int32_t x, int32_t y, int32_t width, int32_t height, int32_t flags) {

		if (SDL_WasInit(SDL_INIT_EVERYTHING) != SDL_INIT_EVERYTHING) {
			SDL_Init(SDL_INIT_EVERYTHING);
		}

#ifdef AE_API_GL
		SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
		SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 4);
		SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
		SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
		SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);


		SDL_GL_SetAttribute(SDL_GL_SHARE_WITH_CURRENT_CONTEXT, 1);
#elif AE_API_GLES
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
    
        SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
        SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    
        SDL_GL_SetAttribute(SDL_GL_SHARE_WITH_CURRENT_CONTEXT, 1);
#endif
#ifdef AE_SHOW_API_DEBUG_LOG
		SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_DEBUG_FLAG);
#endif

		Window *window = new Window(title, x, y, width, height, flags);

#if defined(AE_OS_WINDOWS) || defined(AE_OS_LINUX) || defined(AE_OS_MACOS)
#ifdef AE_API_GL
		if (!gladLoadGL()) {
			throw AtlasException("Error initializing OpenGL");
		}
#elif AE_API_GLES
        if (SDL_GL_LoadLibrary(nullptr) != 0) {
            throw AtlasException("Error initializing OpenGL ES");
        }
        gladLoadGLES2Loader(SDL_GL_GetProcAddress);
        SDL_GL_UnloadLibrary();
#endif
#endif

		int value;

#ifdef AE_SHOW_LOG
		AtlasLog("OpenGL Version: %s", glGetString(GL_VERSION));
		SDL_GL_GetAttribute(SDL_GL_RED_SIZE, &value);
		AtlasLog("Native colorbuffer red component precision %d bits", value);
		SDL_GL_GetAttribute(SDL_GL_GREEN_SIZE, &value);
		AtlasLog("Native colorbuffer green component precision %d bits", value);
		SDL_GL_GetAttribute(SDL_GL_BLUE_SIZE, &value);
		AtlasLog("Native colorbuffer blue component precision %d bits", value);
		SDL_GL_GetAttribute(SDL_GL_DEPTH_SIZE, &value);
		AtlasLog("Native depthbuffer precision %d bits", value);
#endif
		glEnable(GL_DEPTH_TEST);
		glDepthMask(GL_TRUE);
		glDepthFunc(GL_LEQUAL);
		glEnable(GL_CULL_FACE);

		glClearDepthf(1.0f);

		// If the textures aren't working as expected this line should be changed
		glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

		// If texture data isn't returned as expected this line should be changed
		glPixelStorei(GL_PACK_ALIGNMENT, 1);

		glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

#ifdef AE_API_GL
		// Standard in OpenGL ES
		glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);
#endif

#ifdef AE_SHOW_API_DEBUG_LOG
		glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
		glDebugMessageCallback(Engine::DebugCallback, nullptr);
#endif

		// Do the setup for all the classes that need static setup
		Texture::Texture::CheckExtensions();
		Buffer::Buffer::CheckExtensions();
		Texture::Texture::GetMaxAnisotropyLevel();

		LockFramerate();

		Loader::AssetLoader::Init();

		Audio::AudioManager::Configure(48000, 2, 1024);

		Loader::AssetLoader::SetAssetDirectory(assetDirectory);
		Shader::ShaderStage::SetSourceDirectory(shaderDirectory);

		Renderer::OpaqueRenderer::InitShaderBatch();
		Renderer::ShadowRenderer::InitShaderBatch();

		Clock::Update();

		return window;

	}

	ivec2 Engine::GetScreenSize() {

		if (SDL_WasInit(SDL_INIT_EVERYTHING) != SDL_INIT_EVERYTHING) {
			SDL_Init(SDL_INIT_EVERYTHING);
		}

		SDL_DisplayMode displayMode;
		SDL_GetCurrentDisplayMode(0, &displayMode);
		
		return ivec2(displayMode.w, displayMode.h);

	}

	void Engine::LockFramerate() {

		SDL_GL_SetSwapInterval(1);

	}

	void Engine::UnlockFramerate() {

		SDL_GL_SetSwapInterval(0);

	}

	void Engine::Update() {

		Clock::Update();
		Events::EventManager::Update();

	}

	void Engine::DebugCallback(GLenum source, GLenum type, GLuint ID, GLenum severity,
		GLsizei length, const GLchar* message, const void* userParam) {

		// Filter notifications
		if (severity == GL_DEBUG_SEVERITY_NOTIFICATION)
			return;

		std::string output = "OpenGL debug log:\nGenerated by: ";

		switch (source) {
		case GL_DEBUG_SOURCE_API: output.append("OpenGL API"); break;
		case GL_DEBUG_SOURCE_WINDOW_SYSTEM: output.append("Window-system API"); break;
		case GL_DEBUG_SOURCE_SHADER_COMPILER: output.append("Shader compiler");  break;
		case GL_DEBUG_SOURCE_THIRD_PARTY: output.append("Third party"); break;
		case GL_DEBUG_SOURCE_APPLICATION: output.append("Atlas Engine"); break;
		case GL_DEBUG_SOURCE_OTHER: output.append("Unknown source"); break;
		default: break;
		}

		output.append("\nType: ");

		switch(type) {
		case GL_DEBUG_TYPE_ERROR: output.append("Error"); break;
		case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: output.append("Deprecated behavior"); break;
		case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: output.append("Undefined behavior"); break;
		case GL_DEBUG_TYPE_PORTABILITY: output.append("Bad portability"); break;
		case GL_DEBUG_TYPE_PERFORMANCE: output.append("Performance issue"); break;
		case GL_DEBUG_TYPE_OTHER: output.append("Unknown"); break;
		default: break;
		}

		output.append("\nSeverity: ");
		
		switch (severity) {
		case GL_DEBUG_SEVERITY_HIGH: output.append("High"); break;
		case GL_DEBUG_SEVERITY_MEDIUM: output.append("Medium"); break;
		case GL_DEBUG_SEVERITY_LOW: output.append("Low"); break;
		case GL_DEBUG_SEVERITY_NOTIFICATION: output.append("Notification"); break;
		default: break;
		}

		output.append("\nObject ID: " + std::to_string(ID));

		output.append("\nMessage: " + std::string(message));

		AtlasLog("%s", output.c_str());

	}

}