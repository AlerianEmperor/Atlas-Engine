#extension GL_ARB_shader_ballot : require

#include <common.hsh>
#include <intersections.hsh>
#include <structures.hsh>
#include <surface.hsh>

#define STACK_SIZE_SM 16
#define STACK_SIZE 48

struct PackedBVHNode {
	uvec4 data0;
	uvec4 data1;
	uvec4 data2;
	uvec4 data3;
};

struct BVHNode {	
	AABB childrenBounds[4];
	int childrenPtr[4];
};

struct SIMDBVHNode {
	vec4 minVec[3];
	vec4 maxVec[3];
	int childrenPtr[4];
};

struct PackedBVHTriangle {
	vec4 v0;
	vec4 v1;
	vec4 v2;
	vec4 d0;
};

struct NodeHit {
	int ptr;
	float dist;
};

layout (std430, binding = 6) buffer Triangles {
	PackedTriangle triangles[];
};

layout (std430, binding = 13) buffer BVHTriangles {
	PackedBVHTriangle bvhTriangles[];
};

layout(std430, binding = 7) buffer Nodes {
	PackedBVHNode nodes[];
};

shared int stackSM[32][STACK_SIZE_SM];

#define STACK_POP(X) { --stackPtr; if (stackPtr < STACK_SIZE_SM) X = stackSM[threadID][stackPtr]; else X = stack[stackPtr - STACK_SIZE_SM]; }
#define STACK_PUSH(X) { if (stackPtr < STACK_SIZE_SM) stackSM[threadID][stackPtr] = X; else stack[stackPtr - STACK_SIZE_SM] = X; stackPtr++; }

BVHNode UnpackNode(PackedBVHNode compressed) {
	BVHNode node;

	vec2 data0 = unpackHalf2x16(compressed.data0.x);
	vec2 data1 = unpackHalf2x16(compressed.data0.y);
	vec2 data2 = unpackHalf2x16(compressed.data0.z);

	node.childrenBounds[0].min = vec3(data0.x, data0.y, data1.x);
	node.childrenBounds[0].max = vec3(data1.y, data2.x, data2.y);

	data0 = unpackHalf2x16(compressed.data1.x);
	data1 = unpackHalf2x16(compressed.data1.y);
	data2 = unpackHalf2x16(compressed.data1.z);

	node.childrenBounds[1].min = vec3(data0.x, data0.y, data1.x);
	node.childrenBounds[1].max = vec3(data1.y, data2.x, data2.y);

	data0 = unpackHalf2x16(compressed.data2.x);
	data1 = unpackHalf2x16(compressed.data2.y);
	data2 = unpackHalf2x16(compressed.data2.z);

	node.childrenBounds[2].min = vec3(data0.x, data0.y, data1.x);
	node.childrenBounds[2].max = vec3(data1.y, data2.x, data2.y);

	data0 = unpackHalf2x16(compressed.data3.x);
	data1 = unpackHalf2x16(compressed.data3.y);
	data2 = unpackHalf2x16(compressed.data3.z);

	node.childrenBounds[3].min = vec3(data0.x, data0.y, data1.x);
	node.childrenBounds[3].max = vec3(data1.y, data2.x, data2.y);

	node.childrenPtr[0] = int(compressed.data0.w);
	node.childrenPtr[1] = int(compressed.data1.w);
	node.childrenPtr[2] = int(compressed.data2.w);
	node.childrenPtr[3] = int(compressed.data3.w);

	return node;
}

/*
SIMDBVHNode UnpackNode(PackedBVHNode compressed) {
	SIMDBVHNode node;

	vec2 data0 = unpackHalf2x16(compressed.data0.x);
	vec2 data1 = unpackHalf2x16(compressed.data0.y);
	vec2 data2 = unpackHalf2x16(compressed.data0.z);

	node.childrenBounds[0].min = vec3(data0.x, data0.y, data1.x);
	node.childrenBounds[0].max = vec3(data1.y, data2.x, data2.y);

	node.childrenPtr[0] = int(compressed.data0.w);
	node.childrenPtr[1] = int(compressed.data1.w);
	node.childrenPtr[2] = int(compressed.data2.w);
	node.childrenPtr[3] = int(compressed.data3.w);

	return node;
}
*/

void CheckLeafClosest(inout Ray ray, int nodePtr, float tmin, float tmax) {
		
	int triPtr = ~nodePtr;
	bool endOfNode = false;
	
	vec3 sol, v0, v1, v2, n;
	
	while (!endOfNode) {
		v0 = bvhTriangles[triPtr].v0.xyz;
		v1 = bvhTriangles[triPtr].v1.xyz;
		v2 = bvhTriangles[triPtr].v2.xyz;
		endOfNode = bvhTriangles[triPtr].v0.w > 0.0;
		float d = 0.0;
#ifdef BACKFACE_CULLING
		n = cross(v0 - v1, v0 - v2);
		d = dot(n, ray.direction);
#endif
		bool intersect = IntersectTriangle(ray, v0, v1, v2, sol);
		if (intersect && sol.x > tmin && sol.x < tmax && d <= 0.0) {
			if (sol.x < ray.hitDistance) {
				ray.hitDistance = sol.x;
				ray.hitID = triPtr;
			}
		}
		triPtr++;
	}
	
}

bool CheckLeaf(inout Ray ray, int nodePtr, float tmin, float tmax) {
		
	int triPtr = ~nodePtr;
	bool endOfNode = false;
	
	vec3 sol, v0, v1, v2, n;
	bool hit = false;
	
	while (!endOfNode && !hit) {
		v0 = bvhTriangles[triPtr].v0.xyz;
		v1 = bvhTriangles[triPtr].v1.xyz;
		v2 = bvhTriangles[triPtr].v2.xyz;
		endOfNode = bvhTriangles[triPtr].v0.w > 0.0;
		float d = 0.0;
#ifdef BACKFACE_CULLING
		n = cross(v0 - v1, v0 - v2);
		d = dot(n, ray.direction);
#endif
		bool intersect = IntersectTriangle(ray, v0, v1, v2, sol);
		if (intersect && sol.x > tmin && sol.x < tmax && d <= 0.0) {			
			hit = true;
			ray.hitDistance = sol.x;
			ray.hitID = triPtr;
		}
		triPtr++;
	}

	return hit;
	
}

float CheckLeafTransparency(inout Ray ray, int nodePtr, float tmin, float tmax, float transparency) {

	int triPtr = ~nodePtr;
	bool endOfNode = false;
	
	vec3 sol, v0, v1, v2, n;
	
	while (!endOfNode) {
		Triangle tri = UnpackTriangle(triangles[triPtr]);
		v0 = tri.v0.xyz;
		v1 = tri.v1.xyz;
		v2 = tri.v2.xyz;
		endOfNode = tri.endOfNode;
		float d = 0.0;
#ifdef BACKFACE_CULLING
		n = cross(v0 - v1, v0 - v2);
		d = dot(n, ray.direction);
#endif
		bool intersect = IntersectTriangle(ray, v0, v1, v2, sol);
		if (intersect && sol.x > tmin && sol.x < tmax && d <= 0.0) {
			ray.hitDistance = sol.x;
			ray.hitID = triPtr;
			transparency *= (1.0 - GetOpacity(tri, sol.yz));
		}
		triPtr++;
	}

	return transparency;

}

void HitClosest(inout Ray ray, float tMin, float tMax) {
	
	int stack[STACK_SIZE - STACK_SIZE_SM];
	uint stackPtr = 0u;
	int nodePtr = 0;
	uint threadID = gl_LocalInvocationIndex;
	STACK_PUSH(nodePtr);

	ray.hitDistance = tMax;
	
	while (stackPtr != 0u) {		
		if(nodePtr < 0) {
			CheckLeafClosest(ray, nodePtr, tMin, ray.hitDistance);
			STACK_POP(nodePtr);
		}
		else {
			BVHNode node = UnpackNode(nodes[nodePtr]);

			NodeHit hits[4];
			hits[0].ptr = node.childrenPtr[0];
			hits[1].ptr = node.childrenPtr[1];
			hits[2].ptr = node.childrenPtr[2];
			hits[3].ptr = node.childrenPtr[3];

			// We could use SIMD here to exploit our four nodes
			IntersectAABB(ray, node.childrenBounds[0], tMin, ray.hitDistance, hits[0].dist);
			IntersectAABB(ray, node.childrenBounds[1], tMin, ray.hitDistance, hits[1].dist);
			IntersectAABB(ray, node.childrenBounds[2], tMin, ray.hitDistance, hits[2].dist);
			IntersectAABB(ray, node.childrenBounds[3], tMin, ray.hitDistance, hits[3].dist);

			NodeHit tmpHit;
			if (hits[1].dist < hits[0].dist) {
                tmpHit = hits[1];
				hits[1] = hits[0];
				hits[0] = tmpHit;
            }
            if (hits[3].dist < hits[2].dist) {
                tmpHit = hits[3];
				hits[3] = hits[2];
				hits[2] = tmpHit;
            }
            if (hits[2].dist < hits[1].dist) {
                tmpHit = hits[2];
				hits[2] = hits[1];
				hits[1] = tmpHit;
            }
            if (hits[1].dist < hits[0].dist) {
                tmpHit = hits[1];
				hits[1] = hits[0];
				hits[0] = tmpHit;
            }
            if (hits[3].dist < hits[2].dist) {
                tmpHit = hits[3];
				hits[3] = hits[2];
				hits[2] = tmpHit;
            }
            if (hits[2].dist < hits[1].dist) {
                tmpHit = hits[2];
				hits[2] = hits[1];
				hits[1] = tmpHit;
            }

			if (hits[0].dist < ray.hitDistance) {
				if (hits[3].dist < ray.hitDistance) STACK_PUSH(hits[3].ptr);
				if (hits[2].dist < ray.hitDistance) STACK_PUSH(hits[2].ptr);
				if (hits[1].dist < ray.hitDistance) STACK_PUSH(hits[1].ptr);
				nodePtr = hits[0].ptr;
			}
			else {
				STACK_POP(nodePtr);
			}
		}
	}
		
}

bool HitAny(inout Ray ray, float tMin, float tMax) {
	
	int stack[STACK_SIZE - STACK_SIZE_SM];
	bool hit = false;

	uint stackPtr = 0u;
	int nodePtr = 0;
	uint threadID = gl_LocalInvocationIndex;
	STACK_PUSH(nodePtr);

	bool hits[4];
	
	while (stackPtr != 0u && !hit) {
		STACK_POP(nodePtr);
		if(nodePtr < 0) {
			if (CheckLeaf(ray, nodePtr, tMin, tMax)) {
				hit = true;
			}
		}
		else {
			BVHNode node = UnpackNode(nodes[nodePtr]);

			hits[0] = IntersectAABB(ray, node.childrenBounds[0], tMin, tMax);
			hits[1] = IntersectAABB(ray, node.childrenBounds[1], tMin, tMax);
			hits[2] = IntersectAABB(ray, node.childrenBounds[2], tMin, tMax);
			hits[3] = IntersectAABB(ray, node.childrenBounds[3], tMin, tMax);

			if (hits[3]) STACK_PUSH(node.childrenPtr[3]);
			if (hits[2]) STACK_PUSH(node.childrenPtr[2]);
			if (hits[1]) STACK_PUSH(node.childrenPtr[1]);
			if (hits[0]) STACK_PUSH(node.childrenPtr[0]);
		}
	}	

	return hit;
		
}

float HitAnyShadow(inout Ray ray, float tMin, float tMax) {
	
	int stack[STACK_SIZE - STACK_SIZE_SM];
	float transparency = 1.0;

	uint stackPtr = 0u;
	int nodePtr = 0;
	uint threadID = gl_LocalInvocationIndex;
	STACK_PUSH(nodePtr);

	bool hits[4];
	
	while (stackPtr != 0u && transparency > 0.0) {
		STACK_POP(nodePtr);
		if(nodePtr < 0) {
			transparency *= CheckLeafTransparency(ray, nodePtr, tMin, tMax, transparency);
			if (transparency < 0.000001) {
				transparency = 0.0;
			}
			
		}
		else {
			BVHNode node = UnpackNode(nodes[nodePtr]);

			hits[0] = IntersectAABB(ray, node.childrenBounds[0], tMin, tMax);
			hits[1] = IntersectAABB(ray, node.childrenBounds[1], tMin, tMax);
			hits[2] = IntersectAABB(ray, node.childrenBounds[2], tMin, tMax);
			hits[3] = IntersectAABB(ray, node.childrenBounds[3], tMin, tMax);

			if (hits[3]) STACK_PUSH(node.childrenPtr[3]);
			if (hits[2]) STACK_PUSH(node.childrenPtr[2]);
			if (hits[1]) STACK_PUSH(node.childrenPtr[1]);
			if (hits[0]) STACK_PUSH(node.childrenPtr[0]);
		}
	}	

	return transparency;

}