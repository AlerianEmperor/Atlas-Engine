#ifdef SHADOW_FILTERING
uniform sampler2DArrayShadow cascadeMaps;
#else
uniform sampler2DArray cascadeMaps;
#endif
#ifdef SHADOW_FILTERING
const vec2 poissonDisk[16] = vec2[](
  vec2(0.1159636f, -0.6847993f),
  vec2(-0.04063215f, 0.0732412f),
  vec2(-0.5671037f, -0.6256651f),
  vec2(-0.4569176f, -0.175979f),
  vec2(0.517299f, -0.1095803f),
  vec2(0.610924f, -0.6100475f),
  vec2(-0.9603067f, -0.0002735546f),
  vec2(0.9396403f, -0.2230212f),
  vec2(-0.4805221f, 0.2525214f),
  vec2(-0.7926834f, 0.5755413f),
  vec2(-0.2899438f, 0.6315116f),
  vec2(0.09232567f, 0.9606919f),
  vec2(0.3653378f, 0.6443261f),
  vec2(0.8239012f, 0.478811f),
  vec2(-0.07792759f, -0.3342873f),
  vec2(-0.281228f, -0.9247693f) 
);

float random(vec4 seed) {
	
	float dot_product = dot(seed, vec4(12.989f,78.233f,45.164f,94.673f));
    return fract(sin(dot_product) * 43758.5453f);
	
}

float offsetLookup(int cascadeIndex, vec3 shadowCoords, vec2 offset) {

	return texture(cascadeMaps, vec4(shadowCoords.xy + offset, cascadeIndex, shadowCoords.z));
	
}
#endif

float CalculateCascadedShadow(Light light, vec3 modelCoords, vec3 fragmentPosition) {
	
	// We allow a maximum of 4 cascades
	vec4 cascadesDistance = vec4(light.shadow.cascades[0].distance,
								light.shadow.cascades[1].distance,
								light.shadow.cascades[2].distance,
								light.shadow.cascades[3].distance);
								
	vec4 comparison = vec4(-fragmentPosition.z > cascadesDistance.x,
							-fragmentPosition.z > cascadesDistance.y,
							-fragmentPosition.z > cascadesDistance.z,
							-fragmentPosition.z > cascadesDistance.w);
							
	float fIndex = dot(vec4(light.shadow.cascadeCount > 0,
							light.shadow.cascadeCount > 1,
							light.shadow.cascadeCount > 2,
							light.shadow.cascadeCount > 3)
							, comparison);
							
	fIndex = min(fIndex, 4);
	int cascadeIndex = int(fIndex);
	Cascade cascade = light.shadow.cascades[cascadeIndex];
	
	vec4 shadowCoords = cascade.cascadeSpace * vec4(fragmentPosition, 1.0f);
	shadowCoords.z -= light.shadow.bias;
	shadowCoords.xyz /= shadowCoords.w;
	shadowCoords.w = clamp((length(fragmentPosition) + 2.0f - light.shadow.distance) * 0.5f, 0.0f, 1.0f);
	
	shadowCoords.xyz = shadowCoords.xyz * 0.5f + 0.5f;
	if (shadowCoords.w > 0.999f)
		return 1.0f;
	
	float visibility = 1.0f;
	
#ifdef SHADOW_FILTERING
	float partialSum = 1.0f / float(light.shadow.sampleCount);

	for (int i = 0; i < light.shadow.sampleCount; i++) {
		
#ifdef SHADOW_RANDOMIZE
        int index = int(16.0f * random(vec4(floor(modelCoords*light.shadow.sampleRandomness), i))) % 16;
		vec2 offset = poissonDisk[index] * light.shadow.sampleRange / light.shadow.resolution;
#else
		vec2 offset = poissonDisk[i] * light.shadow.sampleRange / (light.shadow.resolution * (cascadeIndex + 1));
#endif
		float factor = offsetLookup(cascadeIndex, shadowCoords.xyz, offset);
		
        visibility -= partialSum * (1.0f - factor);
		
    }
#else
	visibility = texture(cascadeMaps, vec3(shadowCoords.xy, cascadeIndex)).r > shadowCoords.z ? 1.0f : 0.0f;
#endif
	
	return clamp(visibility + shadowCoords.w, 0.0f, 1.0f);
	
}