#ifdef SHADOW_FILTERING
uniform sampler2DShadow firstCascadeTexture;
#else
uniform sampler2D firstCascadeTexture;
#endif
uniform vec2 framebufferResolution;

#ifdef SHADOW_FILTERING
const vec2 poissonDisk[16] = vec2[](
  vec2(0.1159636f, -0.6847993f),
  vec2(-0.04063215f, 0.0732412f),
  vec2(-0.5671037f, -0.6256651f),
  vec2(-0.4569176f, -0.175979f),
  vec2(0.517299f, -0.1095803f),
  vec2(0.610924f, -0.6100475f),
  vec2(-0.9603067f, -0.0002735546f),
  vec2(0.9396403f, -0.2230212f),
  vec2(-0.4805221f, 0.2525214f),
  vec2(-0.7926834f, 0.5755413f),
  vec2(-0.2899438f, 0.6315116f),
  vec2(0.09232567f, 0.9606919f),
  vec2(0.3653378f, 0.6443261f),
  vec2(0.8239012f, 0.478811f),
  vec2(-0.07792759f, -0.3342873f),
  vec2(-0.281228f, -0.9247693f) 
);

float random(vec4 seed) {
	
	float dot_product = dot(seed, vec4(12.989f,78.233f,45.164f,94.673f));
    return fract(sin(dot_product) * 43758.5453f);
	
}

float offsetLookup(vec3 shadowCoords, vec2 offset) {
	
	return texture(firstCascadeTexture, vec3(shadowCoords.xy + offset, shadowCoords.z));
	
}
#endif

float CalculateShadow(Light light, vec3 modelCoords, vec4 shadowCoords) {
	
	shadowCoords.xyz = shadowCoords.xyz * 0.5f + 0.5f;
	
	if (shadowCoords.w > 0.999f)
		return 1.0f;
	
	float visibility = 1.0f;
	
#ifdef SHADOW_FILTERING
	float partialSum = 1.0f / float(light.shadow.sampleCount);

	for (int i = 0; i < light.shadow.sampleCount; i++) {
		
#ifdef SHADOW_RANDOMIZE
        int index = int(16.0f * random(vec4(floor(modelCoords*light.shadow.sampleRandomness), i))) % 16;
		vec2 offset = poissonDisk[index] / (framebufferResolution * light.shadow.sampleRange);
#else
		vec2 offset = poissonDisk[i] / (framebufferResolution * light.shadow.sampleRange);
#endif
		float factor = offsetLookup(shadowCoords.xyz, offset);
		
        visibility -= partialSum * (1.0f - factor);
		
    }
#else
	visibility = texture(firstCascadeTexture, shadowCoords.xy).r > shadowCoords.z ? 1.0f : 0.0f;
#endif
	
	return clamp(visibility + shadowCoords.w, 0.0f, 1.0f);
	
}